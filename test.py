#!/usr/bin/python
# Wrapper for all v9fs benchmarks
# this code expects everything to just work
# function to output necessary files for run (hwinfo, run config) returns index of run config

import os
import subprocess
import socket
import time
import csv
import pandas as pd

class BenchTarget:
    def __init__(self, name, cmd, source, fstab):
        self.cmd = cmd
        self.name = name
        self.source = source
        self.fstab = fstab
    
    def __str__(self):
        return self.name

    def start(self):
        if(self.cmd != ""):
            self.p = subprocess.Popen( self.cmd, stdin=None, stdout=None, stderr=None, close_fds=True)
    
    def done(self):
        if(self.cmd != ""):
            self.p.terminate()

class BenchProgress:
    def __init__(self, t, sd):
        self.iteration = 0
        self.total = t
        self.stepDesc = sd
    
    def step( self, note ):
        self.iteration = self.iteration + 1
        self.stepDesc( note, self.iteration, self.total )

def cpu(cmd, host, fst):
    cfst=""
    if(host==""):
        host="localhost"
    if(fst != ""):
        cfst="-fstab "+fst
    return subprocess.check_output("../cpu/bin/cpu "+ cfst + " " + host + " " +cmd, shell=True, stdin=subprocess.DEVNULL, stderr=subprocess.STDOUT).decode('utf-8')

def get_gcc_vers():
    return subprocess.check_output("gcc -v 2>&1 | tail -1", shell=True).decode('utf-8').split()[2]

def get_golang_vers():
    return subprocess.check_output("go version 2>&1", shell=True).decode('utf-8').split()[2]

def get_host_kernel_vers():
    return subprocess.check_output("uname -r 2>&1", shell=True).decode('utf-8').split()[0]

def get_guest_kernel_vers():
    return cpu("uname -r", "localhost", "").split()[0]

def get_distro():
    return subprocess.check_output("lsb_release -d", shell=True).decode('utf-8').split()[1:]

def get_qemu_vers():
    output = subprocess.check_output("qemu-system-x86_64 -version", shell=True).decode('utf-8').split('\n')
    return [ output[0].split()[3] , output[0][output[0].find("(")+1:output[0].find(")")] ]

def run_config( notes ):
    # check if hostname already has an info file (hopefully was generated by superuser)
    hostname = socket.gethostname()
    if(os.path.exists("hw/"+hostname) == False):
        os.system("lshw -notime -sanitize -json > hw/"+hostname)
    cfgline = [ time.time(), hostname, get_host_kernel_vers(), get_guest_kernel_vers(), get_qemu_vers(), get_golang_vers(), get_gcc_vers(), get_distro(), notes ]
    with open('configs.csv', 'a', encoding='UTF8') as f:
        writer = csv.writer(f)
        writer.writerow(cfgline)
    return subprocess.check_output("wc -l configs.csv", shell=True).decode('utf-8').split()[0]

def bw_cmd(blocksize, source, s):
    return "dd if="+source+" of=/mnt/root/test2 bs="+str(blocksize)+" count="+str(s)+" 2>&1 | tail -1"

def bw_parse( result ):
    components = result.split();
    if(components[-1] != "MB/s"):
        print("Warnings: units assumption broken ("+result+")")
        return -1;
    return components[-2]

def bandwidth( configs, blocksizes, iterations, size, notes, progress, logging ):
    runidx = run_config(notes)
    td = pd.DataFrame( { "Run Config": [], "Target": [], "Blocksize": [], "Iteration": [], "Bandwidth": []})
    with open('bandwidth.csv', 'a', encoding='UTF8') as f:
        writer = csv.writer(f)
        for c in configs:
            c.start()
            # warmup run first
            cpu(bw_cmd(blocksizes[0], c.source, int(size/blocksizes[0])), "localhost", c.fstab)
            for b in blocksizes:
                sz = int(size/b)
                for i in range(iterations):
                    if(logging != None):
                        logging.debug(bw_cmd(b, c.source, sz))
                    result = float(bw_parse(cpu(bw_cmd(b, c.source, sz), "localhost", c.fstab)))
                    if(logging != None):
                        logging.debug((str(c)+" " + str(b) + " " + str(i) + " " + str(result)))
                    if(result < 0):
                        raise ValueError("Bad data")
                    if(progress != None):
                        progress.step((str(c)+" " + str(b) + " " + str(i) + " " + str(result)))
                    writer.writerow([runidx, str(c), b, i, result] )
                    td.loc[len(td.index)] = [runidx, str(c), b, i, result]
            c.done()
    return td

def refine( results ):
    cs = results['Target'].unique()
    bs = results['Blocksize'].unique()
    processed = pd.DataFrame( { "Target": [], "Blocksize": [],  "MeanBW": [], "MinBW": [], "MaxBW": [], "MaxStdD": [] } )
    for c in cs:
        for b in bs:
            q = 'Target == "'+c+'" and Blocksize == '+str(b)
            row = results.query(q)
            first = row.head(1)
            processed.loc[len(processed.index)] = [ c, b, row['Bandwidth'].mean(),row['Bandwidth'].min(),row['Bandwidth'].max(), row['Bandwidth'].std() ]
    return processed
